#!/usr/bin/env node

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { z } from 'zod';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

const RAW_DATA_DIR = path.join(repoRoot, 'data', 'raw');
const GENERATED_DATA_DIR = path.join(repoRoot, 'data', 'generated');
const PUBLIC_DATA_DIR = path.join(repoRoot, 'public', 'data');
const GENERATED_SRC_DIR = path.join(repoRoot, 'src', 'lib', 'generated');

const CompanyInputSchema = z.object({
  id: z.number().int().positive(),
  slug: z.string().min(1),
  name: z.string().min(1),
  country: z.number().int(),
  logo: z.string().min(1),
  description: z.string().min(1),
  start_date: z.number().int(),
  websites: z.union([z.array(z.string().min(1)).nonempty(), z.string().min(1)]),
  founded_year: z.string().min(1).optional(),
  headquarters: z.string().min(1).optional(),
  notable_franchises: z.array(z.string().min(1)).optional(),
});

const PlatformInputSchema = z.object({
  id: z.number().int().positive(),
  company: z.number().int().positive(),
  slug: z.string().min(1),
  name: z.string().min(1),
  logo: z.string().min(1),
  description: z.string().min(1),
  release_date: z.number().int().optional(),
  release_year: z.string().min(1).optional(),
  file_extensions: z.array(z.string().min(1)).optional(),
});

const normalizeWebsites = (websites) => {
  if (Array.isArray(websites)) {
    return websites.map((url) => url.trim()).filter((url) => url.length > 0);
  }
  return websites
    .split(',')
    .map((url) => url.trim())
    .filter((url) => url.length > 0);
};

const normalizeCompanies = (companies) =>
  companies
    .sort((a, b) => a.id - b.id)
    .map((company) => ({
      id: company.id,
      slug: company.slug,
      name: company.name,
      country: company.country,
      logo: company.logo,
      description: company.description,
      startDate: company.start_date,
      websites: normalizeWebsites(company.websites),
      foundedYear: company.founded_year ?? null,
      headquarters: company.headquarters ?? null,
      notableFranchises: company.notable_franchises ?? [],
    }));

const normalizePlatforms = (platforms, companyLookup) =>
  platforms
    .sort((a, b) => a.id - b.id)
    .map((platform) => {
      const owningCompany = companyLookup.get(platform.company);
      if (!owningCompany) {
        throw new Error(
          `Platform ${platform.slug} (id=${platform.id}) references unknown company id ${platform.company}`,
        );
      }
      return {
        id: platform.id,
        slug: platform.slug,
        name: platform.name,
        companyId: owningCompany.id,
        companySlug: owningCompany.slug,
        logo: platform.logo,
        description: platform.description,
        releaseDate: platform.release_date ?? null,
        releaseYear: platform.release_year ?? null,
        fileExtensions: platform.file_extensions ?? [],
      };
    });

const readJsonlFile = async (filename, schema) => {
  const filePath = path.join(RAW_DATA_DIR, filename);
  const content = await fs.readFile(filePath, 'utf8');
  const lines = content
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0 && !line.startsWith('#'));

  const records = [];
  for (const [index, line] of lines.entries()) {
    try {
      const parsed = JSON.parse(line);
      records.push(schema.parse(parsed));
    } catch (error) {
      if (error instanceof z.ZodError) {
        const issues = error.issues
          .map((issue) => `${issue.path.join('.') || '<root>'}: ${issue.message}`)
          .join('; ');
        throw new Error(`Validation failed for ${filename} on line ${index + 1}: ${issues}`);
      }
      throw new Error(`Unable to parse ${filename} on line ${index + 1}: ${(error && error.message) || error}`);
    }
  }

  return records;
};

const writeJsonFile = async (filename, data) => {
  const payload = `${JSON.stringify(data, null, 2)}\n`;
  await fs.writeFile(filename, payload, 'utf8');
};

const writeGeneratedModule = async (companies, platforms) => {
  const header = `// This file is auto-generated by scripts/generate-data.mjs. Do not edit manually.\n\n`;
  const companyInterface =
    `export interface GeneratedCompany {\n` +
    `  id: number;\n` +
    `  slug: string;\n` +
    `  name: string;\n` +
    `  country: number;\n` +
    `  logo: string;\n` +
    `  description: string;\n` +
    `  startDate: number;\n` +
    `  websites: string[];\n` +
    `  foundedYear: string | null;\n` +
    `  headquarters: string | null;\n` +
    `  notableFranchises: string[];\n` +
    `}\n\n`;
  const platformInterface =
    `export interface GeneratedPlatform {\n` +
    `  id: number;\n` +
    `  slug: string;\n` +
    `  name: string;\n` +
    `  companyId: number;\n` +
    `  companySlug: string;\n` +
    `  logo: string;\n` +
    `  description: string;\n` +
    `  releaseDate: number | null;\n` +
    `  releaseYear: string | null;\n` +
    `  fileExtensions: string[];\n` +
    `}\n\n`;
  const companiesExport = `export const companies: GeneratedCompany[] = ${JSON.stringify(companies, null, 2)};\n\n`;
  const platformsExport = `export const platforms: GeneratedPlatform[] = ${JSON.stringify(platforms, null, 2)};\n`;

  const moduleContents = header + companyInterface + platformInterface + companiesExport + platformsExport;

  const targetPath = path.join(GENERATED_SRC_DIR, 'libraryData.ts');
  await fs.writeFile(targetPath, moduleContents, 'utf8');
};

const ensureDirectories = async () => {
  await Promise.all([
    fs.mkdir(GENERATED_DATA_DIR, { recursive: true }),
    fs.mkdir(PUBLIC_DATA_DIR, { recursive: true }),
    fs.mkdir(GENERATED_SRC_DIR, { recursive: true }),
  ]);
};

const run = async () => {
  await ensureDirectories();

  const rawCompanies = await readJsonlFile('companies.jsonl', CompanyInputSchema);
  const rawPlatforms = await readJsonlFile('platforms.jsonl', PlatformInputSchema);

  const companies = normalizeCompanies(rawCompanies);
  const companyLookup = new Map(companies.map((company) => [company.id, company]));
  const platforms = normalizePlatforms(rawPlatforms, companyLookup);

  await Promise.all([
    writeJsonFile(path.join(GENERATED_DATA_DIR, 'companies.json'), companies),
    writeJsonFile(path.join(GENERATED_DATA_DIR, 'platforms.json'), platforms),
    writeJsonFile(path.join(PUBLIC_DATA_DIR, 'companies.json'), companies),
    writeJsonFile(path.join(PUBLIC_DATA_DIR, 'platforms.json'), platforms),
    writeGeneratedModule(companies, platforms),
  ]);
};

run().catch((error) => {
  console.error('[generate-data] failed:', error);
  process.exitCode = 1;
});
